I) Tư duy cốt lõi (1 trang)

Luôn tồn tại hai rổ (basket): SELL và BUY. Mỗi rổ = 1 market (khởi phát) + (N-1) limit cùng hướng tạo thành grid.

Khi một rổ bị âm (theo xu hướng thị trường), hệ thống mở một rổ đối hướng nhỏ (hedge) có TSL. Rổ đối hướng “gặt” nhịp hồi → lợi nhuận của nó kéo điểm TP gộp (thanh đỏ/xanh) của rổ đang âm về gần giá.

Khi giá chạm TP gộp của rổ đang âm → đóng toàn rổ ở BE + δ (lời nhỏ), đảo vai: rổ còn lại thành rổ “âm” mới, tiếp tục vòng lặp.

TSL START: X = ngưỡng kích trailing cho rổ đang bật TSL (khi đi đúng hướng đủ X point/tick).

RECOVERY #k = các lớp bổ sung (DCA/hedge) được vẽ sẵn theo bậc 1000/2000/3000… để đối phó trend dài: thêm vị thế hợp lý và/hoặc khởi tạo grid đối hướng nhằm kéo TP gộp nhanh hơn.

Kiến trúc tổ chức bằng OOP, controller điều khiển 2 hướng A/B, state-machine, rescue-decision, order-validator như tài liệu “FLOWCHARTS & DIAGRAMS”, “PROMPT-AI” và “ARCHITECTURE DEEP DIVE”. 

FLOWCHART

 

PROMPT_AI

 

ARCHITECTURE_DEEP_DIVE

II) Tham số (MVP)

spacing_mode: PIPS | ATR | HYBRID (ATR*M + min_pips).

grid_levels: số mức/chiều.

lot_base, lot_scale: cố định hay hệ số tăng/giảm.

target_cycle_usd: lợi nhuận ròng mong muốn khi đóng rổ đang âm (= BE + δ).

tsl_start_points: chính là TSL START trên UI; tsl_step_points: bước trail.

recovery_steps: [1000, 2000, 3000…]; recovery_lot: khối lượng cho mỗi lớp.

dd_open_usd: DD (âm) để mở rổ đối hướng nếu chưa mở.

offset_ratio: mở hedge khi giá vượt last_grid ± offset_ratio × spacing.

Giới hạn an toàn: max_cycles_per_side, exposure_cap_lots, session_sl_usd.

(Bộ quy tắc này bọc trong các lớp Controller/Rescue/Spacing/Executor như cấu trúc OOP bạn đã chuẩn hóa. 

PROMPT_AI

)

III) Công thức cần dùng

Trung bình giá rổ
avg_price = sum(lot_i * price_i) / sum(lot_i)

PnL rổ (đơn giản hóa)

BUY: pnl = (Bid - avg_price) * point_value * total_lot

SELL: pnl = (avg_price - Ask) * point_value * total_lot

Mức TP gộp (thanh đỏ/xanh)
Tìm mức giá tp_price sao cho PnL rổ ≈ +target_cycle_usd (BE + δ).

Kéo TP bằng hedge
Khi rổ đối hướng đóng chốt lãi profit_hedge, thì giảm target_cycle_usd của rổ đang âm tương ứng → dịch tp_price lại gần giá hiện tại.

IV) Pseudo-code (đầy đủ, bám OOP)
1) Khung vòng đời (controller)
OnInit():
    svc = Services(spread_guard, logger, executor, spacing, rescue, ledger)
    A = CGridDirection(symbol, SELL, params, svc)
    B = CGridDirection(symbol, BUY,  params, svc)
    controller = CLifecycleController(A, B, params, svc)
    controller.Init()

OnTick():
    controller.Update()

class CLifecycleController:
    method Init():
        A.Init(price_now)
        B.Init(price_now)

    method Update():
        price = GetPrice()
        A.Update(price)
        B.Update(price)

        // 1) Đánh giá bên nào đang thua
        losing = (A.IsLosing() ? A : (B.IsLosing() ? B : None))
        winning = (losing == A ? B : (losing == B ? A : None))

        // 2) Quyết định rescue (mở rổ đối hướng nhỏ nếu cần)
        if losing != None:
            if rescue.ShouldRescue(losing.LastGridPrice(), price, losing.DrawdownUSD()):
                OpenOppositeRescue(winning, price)

        // 3) Đóng rổ theo TP gộp/TSL
        A.TryCloseByBasketTP(price)
        B.TryCloseByBasketTP(price)

        // 4) Đảo vai (sau khi một rổ bị đóng)
        if A.BasketClosedRecently():
            MaybeReopenOppositeIfOtherSideStillLosing(A, B, price)
        if B.BasketClosedRecently():
            MaybeReopenOppositeIfOtherSideStillLosing(B, A, price)

        // 5) Ngưỡng an toàn phiên/gộp
        if ledger.ExceedsLimits():
            CloseAllAndHalt()


Flow tổng thể & rescue decision khớp với sơ đồ trong FLOWCHART.md (High-Level EA Flow, Rescue Decision). 

FLOWCHART

2) Một hướng lưới (CGridDirection)
class CGridDirection:
    fields:
        dir, levels[], total_lot, avg_price
        basket_pnl, basket_tp_price, tsl_on
        last_grid_price, losing_flag
        params, services

    method Init(start_price):
        BuildInitialGrid(start_price)

    method Update(price):
        UpdateFillsAndPnL(price)        // refresh tickets, avg, pnl
        ApplyTrailingAndBE(price)       // kích hoạt/di chuyển TSL khi đủ điều kiện
        MaintainGrid(price)             // bảo toàn số lượng pending, dọn lệnh quá xa

    method BuildInitialGrid(start_price):
        spacing = services.spacing.SpacingPips()
        // 1 market (khởi phát) + (N-1) limits
        PlaceMarket(dir, params.lot_base)
        for k in 1..(params.grid_levels - 1):
            level_price = start_price ± k * spacing (± theo dir)
            PlaceLimit(dir, level_price, LotAt(k))

        last_grid_price = outermost(levels).price
        RecomputeBasketTargets()

    method UpdateFillsAndPnL(price):
        RefreshLevelStatuses()
        total_lot = sum(l.level_lot where filled)
        avg_price = weighted average over filled
        basket_pnl = ComputePnL(dir, avg_price, price)
        losing_flag = (basket_pnl < 0)

    method ApplyTrailingAndBE(price):
        if params.tsl_enabled:
            if MovedInFavourFrom(avg_price, price) >= params.tsl_start_points:
                tsl_on = true
            if tsl_on:
                MoveBasketSL(price -/+ params.tsl_step_points)

    method TryCloseByBasketTP(price):
        // Mục tiêu: đóng rổ đang âm ở BE + δ hoặc đóng rổ đang lời theo TSL
        if basket_pnl >= TargetForThisBasket():
            CloseAllFilledLevels()       // đóng đồng thời -> hiện tượng "thanh đỏ/xanh" bị chạm
            MarkBasketClosed()

    method RecomputeBasketTargets():
        // tính basket_tp_price sao cho đóng rổ đạt BE + δ
        basket_tp_price = SolveTPPriceFor(target_cycle_usd)

    method LastGridPrice(): return last_grid_price
    method IsLosing(): return losing_flag

3) Hedge/Recovery Engine
class CRescueEngine:
    method ShouldRescue(last_grid, price, dd_usd):
        condA = price breached (last_grid + offset_ratio * spacing)  // "đâm thủng lưới"
        condB = dd_usd >= dd_open_usd
        condC = cooldown done AND cycles < max_cycles AND exposure OK
        return (condA OR condB) AND condC

OpenOppositeRescue(winner, price):
    // mở hedge nhỏ + đặt các BUY/SELL limit như video (H5)
    winner.OpenRescueBasket(price, lot=params.recovery_lot,
                            steps=params.recovery_steps, tsl=true)


Cấu trúc Rescue/Spacing/Executor/Logger & checklist validate giá/độ trễ… bám theo chuẩn mà bạn đã đặt trong “PROMPT-AI.md”. 

PROMPT_AI

V) Flowcharts (Mermaid)

Các lưu đồ dưới đây tương thích với bộ flow/state bạn đã có (High-Level EA Flow, Lifecycle & Rescue). Mình thêm Basket TP/TSL và Đảo vai để đúng hành vi trong 8 hình.

1) Vòng lặp điều khiển (bổ sung Basket TP/Đảo vai)
flowchart TD
    T[OnTick] --> U[Update A & B]
    U --> V{Bên nào đang âm?}
    V -- A --> R[Rescue check cho A]
    V -- B --> S[Rescue check cho B]
    V -- Không --> W[Chỉ maintain]
    R --> X{Điều kiện rescue đạt?}
    S --> Y{Điều kiện rescue đạt?}
    X -- Yes --> O[Open hedge cho B]
    Y -- Yes --> P[Open hedge cho A]
    X -- No --> W
    Y -- No --> W
    U --> Q{TP/TSL chạm ở A hoặc B?}
    Q -- Có --> Z[Đóng rổ đó + tính lãi ròng]
    Z --> AA{Bên còn lại còn âm lớn?}
    AA -- Có --> AB[Reopen winner (đảo vai)]
    AA -- Không --> AC[Resolved/Cycle++]
    W --> AD{Breach limit?}
    AD -- Yes --> AE[Close All & Halt]
    AD -- No --> T


(Ý tưởng này kế thừa flow tổng quát và state machine trong FLOWCHART.md. 

FLOWCHART

)

2) Basket nội bộ (TP gộp + TSL)
flowchart LR
    A[UpdateFills & avg_price] --> B{PnL >= Target?}
    B -- Yes --> C[Close all tickets in basket]
    B -- No --> D{Moved ≥ TSL_START?}
    D -- No --> E[Keep]
    D -- Yes --> F[Enable TSL; trail SL with step]
    F --> E

3) Rescue/Hedge mở ngược chiều
flowchart LR
    S[Price breaks last grid OR DD ≥ thres] --> C{Cooldown/Exposure OK?}
    C -- No --> X[Skip]
    C -- Yes --> H[Open opposite basket: 1 market + limits]
    H --> T[TSL enabled on hedge]
    T --> M[Lock profits on pullbacks]
    M --> K[Use profits to pull loser TP closer (recompute)]

VI) Chuỗi sự kiện khớp 8 hình

H1 → H4: A=SELL thành “loser”; ShouldRescue() trả true → B=BUY mở hedge (market + limits) với TSL.

H5 → H6: Hedge BUY chốt lãi từng phần → RecomputeBasketTargets() cho SELL → TP đỏ kéo xuống → SELL đạt BE+δ.

H7: TryCloseByBasketTP() ở SELL = true → đóng toàn rổ SELL + log £15.99. Đảo vai: mở SELL mới để cover BUY còn âm.

H8: BUY đạt target → đóng; SELL mới đang âm nhỏ → vòng lặp tiếp tục.

VII) Kiểm thử & chấp nhận (MVP)

Acceptance (rút gọn từ PROMPT-AI.md):

Không spam order; tất cả lệnh hợp lệ (tôn trọng stops level, spread/freeze, cooldown).

Basket TP/TSL hoạt động đúng; rescue xảy ra theo offset_ratio và dd_open_usd.

Giới hạn exposure_cap_lots, session_sl_usd được tôn trọng; Halt khi vi phạm. 

PROMPT_AI

Backtest checklist

Kịch bản trend dài ít hồi (để kiểm tính an toàn).

Kịch bản range/whipsaw (để kiểm hiệu quả kéo TP).

Log phải rõ: tạo grid, rescue, đóng rổ, đảo vai, lý do skip. 

PROMPT_AI

VIII) Gợi ý scaffold mã (MQL5)

Classes: CLifecycleController, CGridDirection, CRescueEngine, CSpacingEngine, CPortfolioLedger, COrderExecutor, CLogger.

Hàm trọng tâm:

CGridDirection.BuildInitialGrid(), UpdateFillsAndPnL(), TryCloseByBasketTP(), ApplyTrailingAndBE().

CRescueEngine.ShouldRescue(); controller.OpenOppositeRescue().

Hợp đồng vòng đời: OnInit→controller.Init, OnTick→controller.Update, OnDeinit→controller.Shutdown.
(Cấu trúc này lấy trực tiếp từ các doc kiến trúc bạn đã có. 

PROMPT_AI

 

FLOWCHART

)

Lời cuối

Đây không phải lời khuyên đầu tư. Grid/hedge luôn có rủi ro khi gặp trend kéo dài. Hãy giới hạn số lớp recovery, exposure_cap và bắt buộc bật session_sl_usd.